package io.aime.crawl;

import io.aime.cerebellum.CerebellumDHI;
import io.aime.exceptions.MethodStillRunningException;
import io.aime.fetcher.Fetcher;
import io.aime.indexer.Indexer;
import io.aime.parse.ParseSegment;
import io.aime.util.AIMEConfiguration;
import io.aime.util.AIMEConstants;
import io.aime.util.GeneralUtilities;
import io.aime.util.HtmlMessageBuilder;
import io.aime.util.LogEventHandler;
import io.aime.util.Timer;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.swing.SwingWorker;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.ObjectWritable;
import org.apache.log4j.Logger;

/**
 * This class will serve as a entrypoint for all main functions of AIME.
 *
 * <p>
 * All functions will be called using reflection, and they all return an
 * execution code, denoting the result.
 * </p>
 *
 * @author Andreas P. Koenzen <akc at apkc.net>
 * @version 0.2
 */
class CrawlMethods
{

    private static final Logger LOG = Logger.getLogger(CrawlMethods.class.getName());
    private Configuration conf = new AIMEConfiguration().create();
    private String currentRunningFunction = AIMEConstants.NO_FUNCTION_METHOD_NAME.getStringConstant();
    private long elapsedTime = 0L;
    private boolean isFunctionRunning = false;
    private boolean pause = false;

    /**
     * Sent the order to pause the execution of the next method.
     *
     * <p>
     * It's impossible to pause a running method, but we can still pause the
     * execution of the next method.</p>
     */
    void pause()
    {
        pause = true;
        setIsFunctionRunningState(false);
    }

    /**
     * This method will resume a paused thread. It can not resume a stopped
     * thread.
     */
    void resume()
    {
        pause = false;
        setIsFunctionRunningState(true);
        synchronized (this)
        { // Grab the object's monitor or intrinsic lock by synchronizing on the instance.
            notifyAll(); // Notify all threads waiting and release the intrinsic lock.
        }
    }

    /**
     * This method checks if a given function is currently running.
     *
     * @return TRUE if there is a function running, FALSE otherwise.
     */
    private boolean isFunctionRunning()
    {
        return isFunctionRunning;
    }

    /**
     * Mark the running state.
     *
     * @param state The new state.
     */
    private void setIsFunctionRunningState(boolean state)
    {
        isFunctionRunning = state;
    }

    /**
     * Returns the current running function.
     *
     * @return The current running function.
     */
    String getCurrentRunningFunction()
    {
        return currentRunningFunction;
    }

    /**
     * Returns the execution time.
     *
     * @return The time in milliseconds of the current running time.
     *
     * @throws MethodStillRunningException If the method is still executing.
     */
    long getMethodExecutionTime() throws MethodStillRunningException
    {
        if (isFunctionRunning())
        {
            throw new MethodStillRunningException();
        }
        else
        {
            return elapsedTime;
        }
    }

    /**
     * Runs a given method.
     *
     * @param method      The name of the method.
     * @param processName The name of the function.
     * @param params      Parameter's array for the method.
     */
    void runMethod(String method, String processName, Object[] params)
    {
        Timer timer = new Timer();
        timer.starTimer();
        currentRunningFunction = processName;

        Class<?> clazz;
        try
        {
            clazz = Class.forName(this.getClass().getName());
            Method m = (params.length > 2)
                       ? clazz.getDeclaredMethod(
                            method,
                            new Class<?>[]
                            {
                                String.class,
                                SwingWorker.class,
                                Integer.class
                            })
                       : clazz.getDeclaredMethod(
                            method,
                            new Class<?>[]
                            {
                                String.class, Integer.class
                            });

            // Pause the execution of this method.
            while (pause)
            {
                synchronized (this)
                { // Grab the object's monitor or intrinsic lock by synchronizing on the instance.
                    try
                    {
                        wait(); // Holds the thread and releases all intrinsic locks.
                    }
                    catch (InterruptedException ex)
                    {
                        LOG.error("Error waiting on current thread. Error: " + ex.toString(), ex);
                    }
                }
            }

            setIsFunctionRunningState(true); // Mark as running method.
            m.invoke(clazz.newInstance(), params); // Run the method.
        }
        catch (ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex)
        {
            LOG.fatal("Error running process: " + processName + ". Error: " + ex.toString(), ex);
        }
        finally
        {
            setIsFunctionRunningState(false); // Marcar que un metodo no se esta ejecutando.
            timer.endTimer();
            elapsedTime = timer.getExecutionTime();
        }
    }

    /**
     * Grab info from this class meta data file if exists, update the value of
     * the last function, and write back the contents to file.
     *
     * <p>
     * Overwrite previous data.</p>
     *
     * @param function The last ran function.
     */
    private void markLastFunction(String function)
    {
        CerebellumDHI.getInstance().modifyLocalData(CerebellumDHI.AIME_METADATA, CerebellumDHI.AIME_LAST_FUNCTION_DATA, new ObjectWritable(function));
        CerebellumDHI.getInstance().modifyLocalData(CerebellumDHI.AIME_METADATA, CerebellumDHI.AIME_TIME_LAST_FUNCTION_DATA, new ObjectWritable(System.currentTimeMillis()));
        // Remove this function from the list of functions to execute, unless a full cycle is complete, then re-add all functions
        // except "Injection".
        List<String> functions = (List<String>) CerebellumDHI.getInstance().obtainLocalData(CerebellumDHI.AIME_METADATA, CerebellumDHI.AIME_FUNCTIONS_TO_EXECUTE).get();
        functions.remove(function);
        if (functions.isEmpty())
        {
            functions.add(AIMEConstants.GENERATOR_METHOD_NAME.getStringConstant());
            functions.add(AIMEConstants.FETCH_METHOD_NAME.getStringConstant());
            functions.add(AIMEConstants.PARSE_METHOD_NAME.getStringConstant());
            functions.add(AIMEConstants.UPDATE_METHOD_NAME.getStringConstant());
            functions.add(AIMEConstants.INDEX_METHOD_NAME.getStringConstant());
        }
        CerebellumDHI.getInstance().modifyLocalData(
                CerebellumDHI.AIME_METADATA,
                CerebellumDHI.AIME_FUNCTIONS_TO_EXECUTE,
                new ObjectWritable(functions));
    }

    /**
     * Grab info from this class meta data file, and returns the last executed
     * function.
     *
     * @return The last executed function.
     */
    String getLastFunction()
    {
        return (String) CerebellumDHI.getInstance().obtainLocalData(CerebellumDHI.AIME_METADATA, CerebellumDHI.AIME_LAST_FUNCTION_DATA).get();
    }

    /**
     * Launch a new injector process.
     *
     * @param crawlHome The path to the crawling dir
     * @param runner    The runner thread
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void injection(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.INJECTOR_JOB_NAME.getStringConstant() + " ###");
        }

        String[] parameters = new String[]
        {
            (crawlHome + "/" + AIMEConstants.AIME_CRAWLDB_DIR_NAME.getStringConstant()),
            (AIMEConstants.SEEDS_FILE_PATH.getStringConstant())
        };

        Timer timer = new Timer();
        timer.starTimer();
        result = Injector.runProcess(parameters, runner); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.INJECTOR_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.INJECTOR_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }

    /**
     * Launch a new generator process.
     *
     * @param crawlHome The path to the crawling dir.
     * @param runner    The runner thread.
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void generate(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.GENERATOR_JOB_NAME.getStringConstant() + " ###");
        }

        String[] parameters = new String[]
        {
            (crawlHome + "/" + AIMEConstants.AIME_CRAWLDB_DIR_NAME.getStringConstant()),
            (crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant())
        };

        Timer timer = new Timer();
        timer.starTimer();
        result = Generator.runProcess(parameters, runner); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.GENERATOR_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.GENERATOR_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }

    /**
     * Launch a new fetching process.
     *
     * @param crawlHome The path to the crawling dir.
     * @param runner    The runner thread.
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void fetch(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.FETCHER_JOB_NAME.getStringConstant() + " ###");
        }

        String[] parameters = null;
        if (exeType == AIMEConstants.LOCAL_EXECUTION_TYPE.getIntegerConstant())
        {
            parameters = new String[]
            {
                GeneralUtilities.lastFileModified(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()).getAbsolutePath(),
                "-noParsing"
            };
        }
        else
        {
            Path choice = null;
            try
            {
                FileSystem fs = FileSystem.get(conf);
                FileStatus[] fst = fs.listStatus(new Path(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()));
                long lastMod = Long.MIN_VALUE;

                for (FileStatus file : fst)
                {
                    if (file.getModificationTime() > lastMod)
                    {
                        choice = file.getPath();
                        lastMod = file.getModificationTime();
                    }
                }

                parameters = new String[]
                {
                    (choice != null) ? choice.toString() : null, "-noParsing"
                };
            }
            catch (IOException e)
            {
                LOG.fatal("Error trying to find the last segment in DFS. Error: " + e.toString(), e);
            }
        }

        Timer timer = new Timer();
        timer.starTimer();
        result = Fetcher.runProcess(parameters, runner); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.FETCH_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.FETCHER_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }

    /**
     * Launch a new parsing process.
     *
     * @param crawlHome The path to the crawling dir
     * @param runner    The runner thread
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void parse(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.PARSE_JOB_NAME.getStringConstant() + " ###");
        }

        String[] parameters = null;
        if (exeType == AIMEConstants.LOCAL_EXECUTION_TYPE.getIntegerConstant())
        {
            parameters = new String[]
            {
                GeneralUtilities.lastFileModified(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()).getAbsolutePath()
            };
        }
        else
        {
            Path choice = null;
            try
            {
                FileSystem fs = FileSystem.get(this.conf);
                FileStatus[] fst = fs.listStatus(new Path(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()));
                long lastMod = Long.MIN_VALUE;

                for (FileStatus file : fst)
                {
                    if (file.getModificationTime() > lastMod)
                    {
                        choice = file.getPath();
                        lastMod = file.getModificationTime();
                    }
                }

                parameters = new String[]
                {
                    (choice != null) ? choice.toString() : null
                };
            }
            catch (IOException e)
            {
                LOG.fatal("Error trying to find the last segment in DFS. Error: " + e.toString(), e);
            }
        }

        Timer timer = new Timer();
        timer.starTimer();
        result = ParseSegment.runProcess(parameters, runner); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.PARSE_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.PARSE_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }

    /**
     * Launch a new update process.
     *
     * @param crawlHome The path to the crawling dir
     * @param runner    The runner thread
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void update(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.UPDATE_JOB_NAME.getStringConstant() + " ###");
        }

        String[] parameters = null;
        if (exeType == AIMEConstants.LOCAL_EXECUTION_TYPE.getIntegerConstant())
        {
            parameters = new String[]
            {
                (crawlHome + "/" + AIMEConstants.AIME_CRAWLDB_DIR_NAME.getStringConstant()),
                GeneralUtilities.lastFileModified(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()).getAbsolutePath(),
                "-filter",
                "-normalize"
            };
        }
        else
        {
            Path choice = null;
            try
            {
                FileSystem fs = FileSystem.get(this.conf);
                FileStatus[] fst = fs.listStatus(new Path(crawlHome + "/" + AIMEConstants.AIME_SEGMENTS_DIR_NAME.getStringConstant()));
                long lastMod = Long.MIN_VALUE;

                for (FileStatus file : fst)
                {
                    if (file.getModificationTime() > lastMod)
                    {
                        choice = file.getPath();
                        lastMod = file.getModificationTime();
                    }
                }

                parameters = new String[]
                {
                    (crawlHome + "/" + AIMEConstants.AIME_CRAWLDB_DIR_NAME.getStringConstant()),
                    (choice != null) ? choice.toString() : null,
                    "-filter",
                    "-normalize"
                };
            }
            catch (IOException e)
            {
                LOG.fatal("Error trying to find the last segment in DFS. Error: " + e.toString(), e);
            }
        }

        Timer timer = new Timer();
        timer.starTimer();
        result = CrawlDB.runProcess(parameters, runner); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.UPDATE_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.UPDATE_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }

    /**
     * Launch a new indexer process.
     *
     * @param crawlHome The path to the crawling dir
     * @param runner    The runner thread
     * @param exeType   The execution type
     *
     * @throws Exception If the process cannot be done.
     */
    private void index(String crawlHome, SwingWorker<?, ?> runner, Integer exeType) throws Exception
    {
        int result; // Determines the outcome of the function.

        if (runner.isCancelled())
        { // If the thread was interrupted, then return.
            return;
        }

        if (LOG.isInfoEnabled())
        {
            LOG.info("### Running Process: " + AIMEConstants.INDEXER_JOB_NAME.getStringConstant() + " ###");
        }

        Timer timer = new Timer();
        timer.starTimer();
        result = Indexer.runProcess(new String[0], runner, exeType); // Run the job and wait the outcome.
        timer.endTimer();
        // If outcome is error, then interrupt the thread.
        if (result != 0)
        {
            runner.cancel(true);
        }
        // Else mark all as finished.
        else
        {
            markLastFunction(AIMEConstants.INDEX_METHOD_NAME.getStringConstant()); // Mark the last runned function.
            LogEventHandler.addNewEvent(
                    new LogEventHandler(
                            AIMEConstants.INDEXER_JOB_NAME.getStringConstant(),
                            HtmlMessageBuilder.buildFunctionFinishMsg(timer)),
                    AIMEConstants.INFO_EVENT.getIntegerConstant());
        }
    }
}
