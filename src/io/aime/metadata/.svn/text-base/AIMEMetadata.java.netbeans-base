package io.aime.metadata;

// AIME
import io.aime.util.AIMEConstants;
import io.aime.util.FileStoring;

// IO
import java.io.Externalizable;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

// Log4j
import org.apache.log4j.Logger;

// Util
import java.util.TreeMap;

/**
 * This serializable class will hold all meta data information about AIME.
 *
 * <ul>
 * <li>Initialization data</li>
 * <li>CrawlJob meta data</li>
 * </ul>
 *
 * @author K-Zen
 */
public class AIMEMetadata implements Externalizable {

  private static final Logger LOG = Logger.getLogger (AIMEMetadata.class.getName ());
  // Crawl jobs variables.
  private boolean isCycleComplete = false; // If an entire iteration is complete.
  private int completedIterations = 0; // How many complete iterations where performed.
  private String lastFunction = AIMEConstants.NO_FUNCTION_METHOD_NAME.getStringConstant (); // The last function that was executed completelly.
  private long timeLastFunction = 0L; // The time in milliseconds when the last function was finished.
  // Initialization variables.
  private int executionType = 1; // If the execution is local or distributed.
  private int heapSize = 0; // The heap size we are running.
  // Seeds
  private TreeMap<String, TreeMap<String, String>> seeds = new TreeMap<String, TreeMap<String, String>> ();

  /**
   * Always make the constructor private.
   * <p>This time we need to make it public to allow
   * serialization. To create a new instance of the class we
   * must use the method newBuild().</p>
   */
  public AIMEMetadata () {
    // Always empty.
  }

  public static AIMEMetadata newBuild () {
    return new AIMEMetadata ();
  }

  public boolean getIsCycleComplete () {
    return this.isCycleComplete;
  }

  public int getCompletedIterations () {
    return this.completedIterations;
  }

  public String getLastFunction () {
    return this.lastFunction;
  }

  public long getTimeLastFunction () {
    return this.timeLastFunction;
  }

  public int getExecutionType () {
    return this.executionType;
  }

  public int getHeapSize () {
    return this.heapSize;
  }

  public TreeMap<String, TreeMap<String, String>> getSeeds () {
    return this.seeds;
  }

  public AIMEMetadata setIsCycleComplete (Object isCycleComplete) {
    if (!Boolean.class.isInstance (isCycleComplete)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.isCycleComplete = (Boolean) isCycleComplete;
    return this;
  }

  public AIMEMetadata setCompletedIterations (Object completedIterations) {
    if (!Integer.class.isInstance (completedIterations)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.completedIterations = (Integer) completedIterations;
    return this;
  }

  public AIMEMetadata setLastFunction (Object lastFunction) {
    if (!String.class.isInstance (lastFunction)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.lastFunction = (String) lastFunction;
    return this;
  }

  public AIMEMetadata setTimeLastFunction (Object timeLastFunction) {
    if (!Long.class.isInstance (timeLastFunction)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.timeLastFunction = (Long) timeLastFunction;
    return this;
  }

  public AIMEMetadata setExecutionType (Object executionType) {
    if (!Integer.class.isInstance (executionType)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.executionType = (Integer) executionType;
    return this;
  }

  public AIMEMetadata setHeapSize (Object heapSize) {
    if (!Integer.class.isInstance (heapSize)) {
      LOG.warn ("Wrong object passed to AIMEMetadata.");
      return this;
    }

    this.heapSize = (Integer) heapSize;
    return this;
  }

  public AIMEMetadata setSeeds (Object seeds) {
    if (!TreeMap.class.isInstance (seeds)) {
      return this;
    }

    this.seeds = (TreeMap<String, TreeMap<String, String>>) seeds;
    return this;
  }

  @Override
  public void writeExternal (ObjectOutput out) throws IOException {
    out.writeBoolean (this.isCycleComplete);
    out.writeInt (this.completedIterations);
    out.writeUTF (this.lastFunction);
    out.writeLong (this.timeLastFunction);
    out.writeInt (this.executionType);
    out.writeInt (this.heapSize);
    out.writeObject (this.seeds);
  }

  @Override
  public void readExternal (ObjectInput in) throws IOException, ClassNotFoundException {
    this.isCycleComplete = in.readBoolean ();
    this.completedIterations = in.readInt ();
    this.lastFunction = in.readUTF ();
    this.timeLastFunction = in.readLong ();
    this.executionType = in.readInt ();
    this.heapSize = in.readInt ();
    this.seeds = (TreeMap<String, TreeMap<String, String>>) in.readObject ();
  }

  public static AIMEMetadata read () {
    AIMEMetadata data = (AIMEMetadata) FileStoring.getInstance ().readFromFile (
            new File (AIMEConstants.DEFAULT_JOB_DATA_FOLDER.getStringConstant () + "/" + AIMEConstants.METADATA_FILENAME.getStringConstant ()),
            AIMEConstants.METADATA_FILENAME_ENCRYPTED.getBooleanConstant ());

    return (data != null) ? data : AIMEMetadata.newBuild ();
  }

  public static void update (AIMEMetadata data) {
    FileStoring.getInstance ().writeToFile (
            new File (AIMEConstants.DEFAULT_JOB_DATA_FOLDER.getStringConstant () + "/" + AIMEConstants.METADATA_FILENAME.getStringConstant ()),
            data,
            AIMEConstants.METADATA_FILENAME_ENCRYPTED.getBooleanConstant ());
  }
}
